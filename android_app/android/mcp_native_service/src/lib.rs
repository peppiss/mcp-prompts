use binder::{
    Interface, Result, Strong,
    sys::{AIBinder, SpIBinder},
    StatusCode,
};
use std::ffi::c_void;

// This would be generated by the AIDL compiler (e.g., rsbinder-aidl or the AOSP build system)
// We are defining a minimal version here for demonstration purposes.
mod com {
    pub mod sparesparrow {
        pub mod mcp {
            use binder::{
                declare_binder_interface,
                Interface, Result, StatusCode, Strong,
                parcel::Parcel,
            };

            declare_binder_interface! {
                IMcpService["com.sparesparrow.mcp.IMcpService"] {
                    native: BnMcpService,
                    proxy: BpMcpService,
                }
            }

            impl IMcpService for BpMcpService {
                fn getPrompt(&self, id: &str) -> Result<String> {
                    // Implementation for the proxy (client) side would go here.
                    // This is auto-generated in a real build.
                    unimplemented!()
                }
                fn applyTemplate(&self, id: &str, jsonVariables: &str) -> Result<String> {
                    unimplemented!()
                }
                fn listPrompts(&self) -> Result<String> {
                    unimplemented!()
                }
            }
        }
    }
}

use com::sparesparrow::mcp::{BnMcpService, IMcpService};

#[derive(Debug, Default)]
pub struct McpNativeService;

impl Interface for McpNativeService {}

impl IMcpService for McpNativeService {
    fn getPrompt(&self, id: &str) -> Result<String> {
        Ok(format!("{{\"id\":\"{}\", \"content\":\"This is a native prompt.\"}}", id))
    }

    fn applyTemplate(&self, id: &str, json_variables: &str) -> Result<String> {
        Ok(format!("{{\"rendered\":\"Native template '{}' with variables '{}'\"}}", id, json_variables))
    }

    fn listPrompts(&self) -> Result<String> {
        Ok("[{\"id\":\"native-prompt-1\"}, {\"id\":\"native-prompt-2\"}]".to_string())
    }
}

#[no_mangle]
pub extern "C" fn make_mcp_service() -> *mut c_void {
    let service = McpNativeService::default();
    let binder = BnMcpService::new_binder(service, binder::BinderFeatures::default());
    // Leaking the binder object to be owned by the caller (the Android service)
    Box::into_raw(Box::new(binder.as_binder())) as *mut c_void
} 